import { addBill } from '../store/slices/billSlice'; // To dispatch addBill action

/**
 * Generates a bill for a specific room for the current month if one doesn't already exist.
 * @param {object} room - The room object. Must contain id, rentAmount, maintenanceCharge, rentCycleStartDay, status.
 * @param {Array<object>} existingBillsForRoom - Array of bills already existing for this room.
 * @returns {object|null} A new bill object or null if a bill already exists for the current month/year.
 */
export const generateBillForRoom = (room, existingBillsForRoom) => {
  if (room.status !== 'occupied') {
    return null; // Only generate bills for occupied rooms
  }

  const now = new Date();
  const currentMonth = now.getMonth() + 1; // JavaScript months are 0-indexed
  const currentYear = now.getFullYear();

  // Check if a bill for the current month and year already exists
  const billExists = existingBillsForRoom.some(
    bill => bill.roomId === room.id && bill.month === currentMonth && bill.year === currentYear
  );

  if (billExists) {
    return null; // Bill already generated for this period
  }

  const rentCycleStartDay = parseInt(room.rentCycleStartDay, 10);
  if (isNaN(rentCycleStartDay) || rentCycleStartDay < 1 || rentCycleStartDay > 31) {
    console.error(`Invalid rentCycleStartDay for room ${room.id}: ${room.rentCycleStartDay}`);
    return null; // Invalid configuration for due date calculation
  }
  
  // Calculate dueDate: for simplicity, if rentCycleStartDay is e.g., 5th, due date is 5th of current month.
  // More complex logic might be needed if the cycle spans across month ends for generation timing.
  const dueDate = new Date(currentYear, currentMonth - 1, rentCycleStartDay);

  const rentAmount = parseFloat(room.rentAmount) || 0;
  const maintenanceCharge = parseFloat(room.maintenanceCharge) || 0;
  const totalAmount = rentAmount + maintenanceCharge;

  const newBill = {
    // id is generated by the slice reducer
    roomId: room.id,
    propertyId: room.propertyId, // Assuming room object has propertyId
    tenantId: room.renterId || null, // Assuming room object might have renterId when occupied
    month: currentMonth,
    year: currentYear,
    rentAmount,
    maintenanceCharge,
    otherCharges: [], // Initially empty
    totalAmount,
    dueDate: dueDate.toISOString().split('T')[0], // Format as YYYY-MM-DD
    status: 'pending', // Initial status
    generatedDate: now.toISOString().split('T')[0], // Format as YYYY-MM-DD
  };

  return newBill;
};

/**
 * Checks all occupied rooms and generates bills if necessary.
 * @param {Array<object>} allRooms - Array of all room objects from the store.
 * @param {Array<object>} allBills - Array of all bill objects from the store.
 * @param {function} dispatch - The Redux dispatch function.
 */
export const checkAndGenerateBills = (allRooms, allBills, dispatch) => {
  if (!allRooms || !allBills || !dispatch) {
    console.error("Missing parameters for checkAndGenerateBills");
    return;
  }

  console.log("Checking and generating bills...");
  let billsGeneratedCount = 0;

  allRooms.forEach(room => {
    if (room.status === 'occupied') {
      const roomSpecificBills = allBills.filter(bill => bill.roomId === room.id);
      const newBill = generateBillForRoom(room, roomSpecificBills);
      if (newBill) {
        try {
          dispatch(addBill(newBill)); // The slice will add the ID
          billsGeneratedCount++;
          console.log(`Generated bill for room ${room.id} for ${newBill.month}/${newBill.year}`);
        } catch (error) {
          console.error(`Error dispatching addBill for room ${room.id}:`, error);
        }
      }
    }
  });

  if (billsGeneratedCount > 0) {
    console.log(`Finished bill generation. ${billsGeneratedCount} new bill(s) created.`);
  } else {
    console.log("Finished bill generation. No new bills were needed.");
  }
};
